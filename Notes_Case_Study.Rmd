---
title: 'Exploratory Data Analysis in R: Case Study'
author: "Alan"
date: "6 de septiembre de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Course Description

Once you've started learning tools for data manipulation and visualization like dplyr and ggplot2, this course gives you a chance to use them in action on a real dataset. You'll explore the historical voting of the United Nations General Assembly, including analyzing differences in voting between countries, across time, and among international issues. In the process you'll gain more practice with the dplyr and ggplot2 packages, learn about the broom package for tidying model output, and experience the kind of start-to-finish exploratory analysis common in data science.


## Data cleaning and summarizing with dplyr

The best way to learn data wrangling skills is to apply them to a specific case study. Here you'll learn how to clean and filter the United Nations voting dataset using the dplyr package, and how to summarize it into smaller, interpretable units.


```{r}
#install packages
#install.packages("dplyr")
#install.packages("countrycode")
# install.packages("ggplot2")

library("dplyr")
library("countrycode")
library("ggplot2")

votes <- readRDS("votes.rds")
```


### Filtering rows

The vote column in the dataset has a number that represents that country's vote:

1 = Yes
2 = Abstain
3 = No
8 = Not present
9 = Not a member
One step of data cleaning is removing observations (rows) that you're not interested in. In this case, you want to remove "Not present" and "Not a member".

Instructions
Load the dplyr package.
Print the votes table.
Filter out rows where the vote recorded is "not present" or "not a member", leaving cases where it is "yes", "abstain", or "no".


```{r}
# Load the dplyr package
library("dplyr")

# Print the votes dataset
votes

# Filter for votes that are "yes", "abstain", or "no"
votes %>% filter(vote <= 3)
```

### Adding a year column

The next step of data cleaning is manipulating your variables (columns) to make them more informative.

In this case, you have a session column that is hard to interpret intuitively. But since the UN started voting in 1946, and holds one session per year, you can get the year of a UN resolution by adding 1945 to the session number.

Instructions
Use mutate() to add a year column by adding 1945 to the session column.

```{r}
# Add another %>% step to add a year column
votes %>%
  filter(vote <= 3) %>%
  mutate(year = session + 1945 )
```

### Adding a country column

The country codes in the ccode column are what's called Correlates of War codes. This isn't ideal for an analysis, since you'd like to work with recognizable country names.

You can use the countrycode package to translate. For example:

library(countrycode)

Translate the country code 2
countrycode(2, "cown", "country.name")
[1] "United States"

Translate multiple country codes
countrycode(c(2, 20, 40), "cown", "country.name")
[1] "United States" "Canada"        "Cuba"

Instructions
Load the countrycode package.
Convert the country code 100 to its country name.
Add a new country column in your mutate() statement containing country names, using the countrycode() function to translate from the ccode column. Save the result to votes_processed.


```{r}
# Load the countrycode package
library(countrycode)

# Convert country code 100
countrycode(100, "cown", "country.name")

# Add a country column within the mutate: votes_processed
votes_processed <- votes %>%
  filter(vote <= 3) %>%
  mutate(year = session + 1945, country = countrycode(ccode, "cown", "country.name"))
```


### Summarizing the full dataset

In this analysis, you're going to focus on "% of votes that are yes" as a metric for the "agreeableness" of countries.

You'll start by finding this summary for the entire dataset: the fraction of all votes in their history that were "yes". Note that within your call to summarize(), you can use n() to find the total number of votes and mean(vote == 1) to find the fraction of "yes" votes.

Instructions
Print the votes_processed dataset that you created in the previous exercise.
Summarize the dataset using the summarize() function to create two columns:
total: with the number of votes
percent_yes: the percentage of "yes" votes

```{r}
# Print votes_processed
votes_processed

# Find total and fraction of "yes" votes

votes_processed %>%
summarize(total = n(),
          percent_yes = mean(vote == 1))
```

### Summarizing by year

The summarize() function is especially useful because it can be used within groups.

For example, you might like to know how much the average "agreeableness" of countries changed from year to year. To examine this, you can use group_by() to perform your summary not for the entire dataset, but within each year.

Instructions
Add a group_by() to your code to summarize() within each year.


```{r}
# Change this code to summarize by year
votes_processed %>%
  group_by(year) %>%
  summarize(total = n(),
            percent_yes = mean(vote == 1))
```

### Summarizing by country

In the last exercise, you performed a summary of the votes within each year. You could instead summarize() within each country, which would let you compare voting patterns between countries.

Instructions
Change the code in the editor to summarize() within each country rather than within each year. Save the result as by_country.

```{r}
# Summarize by country: by_country
by_country <- votes_processed %>%
  group_by(country) %>%
  summarize(total = n(),
            percent_yes = mean(vote == 1))
```


### Sorting by percentage of "yes" votes

Now that you've summarized the dataset by country, you can start examining it and answering interesting questions.

For example, you might be especially interested in the countries that voted "yes" least often, or the ones that voted "yes" most often.

Instructions
Print the by_country dataset created in the last exercise.
Use arrange() to sort the countries in ascending order of percent_yes.
Arrange the countries by the same variable, but in descending order.

```{r}
# You have the votes summarized by country
by_country <- votes_processed %>%
  group_by(country) %>%
  summarize(total = n(),
            percent_yes = mean(vote == 1))

# Print the by_country dataset
by_country

# Sort in ascending order of percent_yes
by_country %>%
arrange(percent_yes)

# Now sort in descending order
by_country %>%
arrange(desc(percent_yes))
```


### Filtering summarized output

In the last exercise, you may have noticed that the country that voted least frequently, Zanzibar, had only 2 votes in the entire dataset. You certainly can't make any substantial conclusions based on that data!

Typically in a progressive analysis, when you find that a few of your observations have very little data while others have plenty, you set some threshold to filter them out.

Instructions
Use filter() to remove from the sorted data countries that have fewer than 100 votes.


```{r}
# Filter out countries with fewer than 100 votes
by_country %>%
  filter(total > 100) %>%
  arrange(percent_yes)
```

## Data visualization with ggplot2

Once you've cleaned and summarized data, you'll want to visualize them to understand trends and extract insights. Here you'll use the ggplot2 package to explore trends in United Nations voting within each country over time.

### Plotting a line over time

In the last chapter, you learned how to summarize() the votes dataset by year, particularly the percentage of votes in each year that were "yes".

You'll now use the ggplot2 package to turn your results into a visualization of the percentage of "yes" votes over time.

Instructions
The by_year dataset has the number of votes and percentage of "yes" votes each year.

Load the ggplot2 package.
Use ggplot() with the geom_line layer to create a line plot with year on the x-axis and percent_yes on the y-axis.

```{r}
# Define by_year
votes_processed

by_year <- votes_processed %>%
  group_by(year) %>%
  summarize(total = n(),
            percent_yes = mean(vote == 1))

by_year

# Load the ggplot2 package
library("ggplot2")

# Create line plot
ggplot(by_year, aes(x = year, y = percent_yes )) +
geom_line()
```


Other ggplot2 layers

A line plot is one way to display this data. You could also choose to display it as a scatter plot, with each year represented as a single point. This requires changing the layer (i.e. geom_line() to geom_point()).

You can also add additional layers to your graph, such as a smoothing curve with geom_smooth().

Instructions
Change the plot to a scatter plot and add a smoothing curve.


```{r}
# Change to scatter plot and add smoothing curve
ggplot(by_year, aes(year, percent_yes)) +
  geom_point()

# Change to scatter plot and add smoothing curve
ggplot(by_year, aes(year, percent_yes)) +
  geom_point() + geom_smooth()
```



### Summarizing by year and country

You're more interested in trends of voting within specific countries than you are in the overall trend. So instead of summarizing just by year, summarize by both year and country, constructing a dataset that shows what fraction of the time each country votes "yes" in each year.

Instructions
Change the code in the editor to group by both year and country rather than just by year. Save the result as by_year_country.


```{r}
# Group by year and country: by_year_country
by_year_country <- votes_processed %>%
                      group_by(year, country) %>%
                      summarize(total = n(),
                                percent_yes = mean(vote == 1))

by_year_country


```

### Plotting just the UK over time

Now that you have the percentage of time that each country voted "yes" within each year, you can plot the trend for a particular country. In this case, you'll look at the trend for just the United Kingdom.

This will involve using filter() on your data before giving it to ggplot2.

Instructions
Print the by_year_country dataset.
Create a filtered version of the dataset called UK_by_year.
Create a line plot of the percentage of "yes" votes over time for the United Kingdom.

```{r}
# Start with by_year_country dataset
by_year_country <- votes_processed %>%
  group_by(year, country) %>%
  summarize(total = n(),
            percent_yes = mean(vote == 1))

# Print by_year_country
by_year_country

# Create a filtered version: UK_by_year
UK_by_year <- by_year_country %>%
                filter(country %in% c("United Kingdom of Great Britain and Northern Ireland"))

# Line plot of percent_yes over time for UK only
ggplot(UK_by_year, aes(x = year, y = percent_yes)) +  
      geom_line() 
```


### Plotting multiple countries

Plotting just one country at a time is interesting, but you really want to compare trends between countries. For example, suppose you want to compare voting trends for the United States, the UK, France, and India.

You'll have to filter to include all four of these countries and use another aesthetic (not just x- and y-axes) to distinguish the countries on the resulting visualization. Instead, you'll use the color aesthetic to represent different countries.

Instructions
The by_year_country dataset you created in the last exercise is available in your workspace.

Create a filtered version of by_year_country called filtered_4_countries with just the countries listed in the editor (you may find the %in% operator useful here).
Show the trend for each of these countries on the same graph, using color to distinguish each country.

```{r}
# Vector of four countries to examine
countries <- c("United States of America", "United Kingdom of Great Britain and Northern Ireland",
               "France", "India")

# Filter by_year_country: filtered_4_countries
filtered_4_countries <- by_year_country %>% 
                          filter(country %in% countries)

# Line plot of % yes in four countries
ggplot(filtered_4_countries, aes(x = year, y = percent_yes, color = country)) +
  geom_line()

ggplot(filtered_4_countries, aes(x = year, y = percent_yes, color = country)) +
  geom_point() + geom_smooth() 
```

### Faceting by country

Now you'll take a look at six countries. While in the previous exercise you used color to represent distinct countries, this gets a little too crowded with six.

Instead, you will facet, giving each country its own sub-plot. To do so, you add a facet_wrap() step after all of your layers.

Instructions
Create a filtered version that contains these six countries called filtered_6_countries.
Use the filtered dataset (containing summarized data for six countries) to create a plot with one facet for each country.

```{r}
# Vector of six countries to examine
countries <- c("United States of America", "United Kingdom of Great Britain and Northern Ireland",
               "France", "Japan", "Brazil", "India")

# Filtered by_year_country: filtered_6_countries
filtered_6_countries <- by_year_country %>%
                          filter(country %in% countries)

# Line plot of % yes over time faceted by country
ggplot(filtered_6_countries, aes(x = year, y = percent_yes)) +
  geom_line() +
  facet_wrap(~ country)

ggplot(filtered_6_countries, aes(x = year, y = percent_yes, color = country)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ country)



```

### Faceting with free y-axis

In the previous plot, all six graphs had the same axis limits. This made the changes over time hard to examine for plots with relatively little change.

Instead, you may want to let the plot choose a different y-axis for each facet.

Instructions
Change the faceted plot so that the y-axis is freely chosen for each facet, rather than being the same for all six.

```{r}
# Vector of six countries to examine
countries <- c("United States of America", "United Kingdom of Great Britain and Northern Ireland",
               "France", "Japan", "Brazil", "India")

# Filtered by_year_country: filtered_6_countries
filtered_6_countries <- by_year_country %>%
  filter(country %in% countries)

# Line plot of % yes over time faceted by country
ggplot(filtered_6_countries, aes(year, percent_yes)) +
  geom_line() +
  facet_wrap(~ country, scale = "free_y")

ggplot(filtered_6_countries, aes(x = year, y = percent_yes, color = country)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ country, scale = "free_y")
```









## Tidy modeling with broom

While visualization helps you understand one country at a time, statistical modeling lets you quantify trends across many countries and interpret them together. Here you'll learn to use the tidyr, purrr, and broom packages to fit linear models to each country, and understand and compare their outputs.

## Joining and tidying

In this chapter, you'll learn to combine multiple related datasets, such as incorporating information about each resolution's topic into your vote analysis. You'll also learn how to turn untidy data into tidy data, and see how tidy data can guide your exploration of topics and countries over time.



```{r}
# Add three more countries to this list
countries <- c("United States of America", "United Kingdom of Great Britain and Northern Ireland",
               "France", "Japan", "Brazil", "India", "China", "Malaysia", "Singapore")

# Filtered by_year_country: filtered_countries
filtered_countries <- by_year_country %>%
  filter(country %in% countries)

# Line plot of % yes over time faceted by country
ggplot(filtered_countries, aes(year, percent_yes)) +
  geom_line() +
  facet_wrap(~ country, scales = "free_y")

ggplot(filtered_countries, aes(x = year, y = percent_yes, color = country)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ country, scale = "free_y")


```




```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
